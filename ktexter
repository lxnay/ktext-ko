#!/usr/bin/python2
"""

You can use ktexter to test /dev/ktext under different
readers/writers scenarios to simulate the starvation.
This script expects that /dev/ktext is available, so
please load the module first.
Moreover, make sure the user has read/write permissions
on the device (at this time, only root is allowed to
execute this script, see os.getuid()).
Writers are printed in purple.
Readers are printed in teal.

Simple scenario:
	One reader argv[1]
	One writer argv[2]
	Reader frequency: 1Hz argv[3]
	Writer frequency: 1Hz argv[4]
	
	ktexter 1 1 1 1

Hardcode scenario (readers starvation):
	Thirty readers argv[1]
	Ten writers argv[2]
	Reader frquency: 3Hz argv[3]
	Writer frequency: 1Hz argv[3]
	
	ktexter 30 10 3 1

Hardcore scenario (writers starvation):
	Ninety readers argv[1]
	Ten writers argv[2]
	Reader frquency: 1Hz argv[3]
	Writer frequency: 3Hz argv[3]

	ktexter 90 10 1 3
"""

import sys
import os
import threading
import time
import random
random.seed()

class GenericTask(threading.Thread):
    
    def __init__(self, callback, sleep_time):
        threading.Thread.__init__(self)
        self._sleep_time = sleep_time
        self._callback = callback
        self.daemon = True

    def run(self):
        while True:
            sts = self._callback()
            if not sts:
                break
            time.sleep(self._sleep_time)

class Dispatcher(object):

    def __init__(self, n_readers, n_writers, readers_freq,
                 writers_freq, die_seconds):
        self._n_readers = n_readers
        self._n_writers = n_writers
        self._readers_freq = readers_freq
        self._writers_freq = writers_freq
        self._readers_t = float(1)/self._readers_freq
        self._writers_t = float(1)/self._writers_freq
        self._print_generic("Dispatcher init: readers: %d, writers: %d, "
                         "readers_freq: %d, writers_freq: %d, die_seconds: %s" % (
                self._n_readers, self._n_writers, self._readers_freq,
                self._writers_freq, die_seconds))
        self._readers_pool = []
        self._writers_pool = []
        self._phrases = ["one", "two", "three", "four", "five", "six",
                         "seven", "eight", "nine", "ten"]
        self._device_file = "/dev/ktext"
        self._die_time = None

    def _get_random_phrase(self):
        return self._phrases[random.randint(0, len(self._phrases)-1)]

    def _print_teal(self, text):
        sys.stdout.write("\x1b[36m" + text + "\x1b[39;49;00m\n")

    def _print_purple(self, text):
        sys.stdout.write("\x1b[35m" + text + "\x1b[39;49;00m\n")

    def _print_generic(self, text):
        sys.stdout.write(text + "\n")

    def _reader_callback(self):
        th_id = threading.current_thread().ident
        t_start = time.time()
        text = None
        try:
            with open(self._device_file, "r") as dev_f:
                text = dev_f.read()
        except IOError:
            return False
        t_total = time.time() - t_start
        self._print_teal("[%s] read: %s, taken: %.4f" % (
                th_id, text, t_total,))
        if self._die_time is None:
            return True
        if time.time() > self._die_time:
            self._print_teal("[%s] reader dying" % (th_id,))
            # goodbye
            return False
        return True

    def _writer_callback(self):
        th_id = threading.current_thread().ident
        t_start = time.time()
        text = self._get_random_phrase()
        try:
            with open(self._device_file, "w") as dev_f:
                dev_f.write(text)
        except IOError:
            return False
        t_total = time.time() - t_start
        self._print_purple("[%s] write: %s, taken: %.4f" % (
                th_id, text, t_total,))
        if self._die_time is None:
            return True
        if time.time() > self._die_time:
            # goodbye
            self._print_purple("[%s] writer dying" % (th_id,))
            return False
        return True

    def run(self):
        for i in range(self._n_readers):
            th = GenericTask(self._reader_callback, self._readers_t)
            self._readers_pool.append(th)
        for i in range(self._n_writers):
            th = GenericTask(self._writer_callback, self._writers_t)
            self._writers_pool.append(th)

        # randomize with butterfly effect
        for th in self._readers_pool:
            self._print_generic("starting reader: %s" % (th,))
            th.start()
            rand_sleep = float(1) / random.randint(10, 100)
            time.sleep(rand_sleep)

        for th in self._writers_pool:
            self._print_generic("starting writer: %s" % (th,))
            th.start()
            rand_sleep = float(1) / random.randint(5, 10)
            time.sleep(rand_sleep)

        if die_seconds is not None:
            self._die_time = time.time() + die_seconds

        while True:
            alive = [x for x in self._readers_pool + \
                         self._writers_pool if x.is_alive()]
            if not alive:
                return
            # sleep 5 seconds and check again
            time.sleep(5)


if __name__ == "__main__":
    if os.getuid() != 0:
        sys.stderr.write("run as root\n")
        raise SystemExit(1)

    # Can't use argparse because it's not available in <Py2.7
    # And optparse sucks!
    args = sys.argv[1:]
    die_opts = [x for x in args if x.startswith("--die=")]
    for die_opt in die_opts:
        args.remove(die_opt)
    die_seconds = None
    if die_opts:
        die_opt = die_opts[-1]
        try:
            die_seconds = int(die_opt.split("=")[-1])
        except (IndexError, ValueError):
            sys.stderr.write("invalid --die= option\n")
            raise SystemExit(1)

    if not args or "--help" in args or "-h" in args:
        sys.stdout.write("%s <number of readers> <number of writers> "
                         "<readers call frequency in Hz>"
                         " <writers call frequency in Hz>\n" % (
                sys.argv[0],))
        if not args:
            raise SystemExit(1)
        raise SystemExit(0)

    if len(args) != 4:
        sys.stderr.write("invalid arguments, see --help\n")
        raise SystemExit(1)

    n_readers, n_writers, readers_freq, writers_freq = args

    try:
        n_readers = int(n_readers)
    except ValueError:
        sys.stderr.write("invalid numbers of readers\n")
        raise SystemExit(1)

    try:
        n_writers = int(n_writers)
    except ValueError:
        sys.stderr.write("invalid numbers of writers\n")
        raise SystemExit(1)

    try:
        readers_freq = int(readers_freq)
    except ValueError:
        sys.stderr.write("invalid readers frequency\n")
        raise SystemExit(1)

    try:
        writers_freq = int(writers_freq)
    except ValueError:
        sys.stderr.write("invalid writers frequency\n")
        raise SystemExit(1)

    if (n_readers < 1) and (n_writers < 1):
        sys.stderr.write("so, no readers and no writers?\n")
        raise SystemExit(1)

    disp = Dispatcher(n_readers, n_writers, readers_freq,
                      writers_freq, die_seconds)
    disp.run() # blocks
    raise SystemExit(0)
